---
title: "singleRcapture: An R Package for Single-Source Capture-Recapture Models"
author: "Piotr Chlebicki, Maciej Beręsewicz"
date: "`r Sys.Date()`"
output: 
    html_vignette:
        df_print: kable
        toc: true
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{singleRcapture: An R Package for Single-Source Capture-Recapture Models}
  %\VignetteEngine{knitr::rmarkdown_notangle}
bibliography: bibliography.bib
link-citations: true
editor_options: 
  chunk_output_type: console
header-includes:
  - \usepackage{amsmath}
  - \usepackage{amsthm}
  - \usepackage{amssymb}
  - \usepackage{calc}
  - \usepackage{ragged2e}
  - \usepackage[ruled]{algorithm2e}
  - \DeclareMathAlphabet{\mathmybb}{U}{bbold}{m}{n}
  - \newcommand{\1}{\mathcal{I}}
  - \newcommand{\bZero}{\boldsymbol{0}}
  - \newcommand{\bx}{\boldsymbol{x}}
  - \newcommand{\bX}{\boldsymbol{X}}
  - \newcommand{\bbeta}{\boldsymbol{\beta}}
  - \newcommand{\boeta}{\boldsymbol{\eta}}
  - \newcommand{\bW}{\boldsymbol{W}}
  - \newcommand{\bo}{\boldsymbol{o}}  
---

```{=html}
<style>
pre {
  overflow-x: auto;
}
pre code {
  word-wrap: normal;
  white-space: pre;
}
</style>
```

# Introduction {#sec-introduction}

Population size estimation is a methodological approach employed across
multiple scientific disciplines, which serves as the basis for research, policy
formulation, and decision-making processes [cf. @bohning2018capture]. In the
field of statistics, particularly official statistics, precise
population estimates are essential in order to develop robust economic
models, optimize resource allocation, and inform evidence-based
policy [cf. @baffour2013modern]. Social scientists utilize
advanced population estimation techniques to investigate *hard-to-reach*
populations, such as homeless individuals or illicit drug users in an effort to overcome the inherent limitations of conventional census
methodologies. These techniques are crucial for obtaining accurate data
on populations that are typically under-represented or difficult to
access using traditional sampling methods [cf. @vincent2022estimating]. In
ecology and epidemiology, researchers focus on estimating the size of
individual species or disease-affected populations within defined
geographical regions as part of conservation efforts, ecosystem
management, and public health interventions.

Population size estimation can be approached using various methodologies, each with distinct advantages and limitations. Traditional approaches include full enumeration (e.g. censuses) and comprehensive sample surveys, which, while providing detailed data, are often resource-intensive and may result in delayed estimates, particularly for human populations. Alternative methods leverage existing data sources, such as administrative registers or carefully designed small-scale studies in wildlife research, or census coverage surveys [cf. @wolter1986some; @zhang2019note]. Information from these sources is often extracted by applying statistical methods, known as *capture-recapture* or *multiple system estimation*, which rely on data from multiple enumerations of the same population [cf. @dunne2024system]. This approach can be implemented using either a single source with repeated observations, two sources, or multiple sources.

In this paper we focus on methods that involve a single data source with multiple enumerations of the same units [cf. @ztpoisson]. In human population studies, such data can be derived from police records, health system databases, or border control logs; in the case of non-human populations, data of this kind can come from veterinary records or specialized field data. These methods are often applied to estimate hard-to-reach or hidden populations, where standard sampling methods may be inappropriate because of prohibitive costs or problems with identifying population members.

While methods for two or more sources are implemented in various open-source software packages, for instance \textbf{CARE-4} [@yang2006care4] (in \textbf{GAUSS}), \textbf{Rcapture} [@baillargeon2007rcapture], \textbf{marked} [@laake2013marked] or \textbf{VGAM} [@yee2015vgam] (all in \textbf{R}), single-source capture-recapture (SSCR) methods are either not available at all or are only partially implemented in existing \textbf{R} packages or other software. Therefore, the paper attempts to bridge this gap by introducing the \textbf{singleRcapture} package, which implement *state-of-the-art* SSCR methods and offer a user friendly API resembling existing \textbf{R} functions (e.g., `glm`). In the next subsection we describe existing \textbf{R} packages and other software that could be used for estimating population size using SSCR methods.

## Software for capture-recapture with a single source {#sec-software}


The majority of SSCR methods assume zero-truncated distributions or their extensions (e.g., inclusion of one-inflation). The \textbf{Distributions.jl} [@Distributionsjl] (in \textbf{Julia}), \textbf{StatsModels} [@seabold2010statsmodels] (in \textbf{Python}), \textbf{countreg} [@countreg], \textbf{VGAM} [@VGAM-main] or \textbf{distributions3} [@distributions3] (in \textbf{R}) implement some of those truncated distributions (e.g. \texttt{distributions3::ZTPoisson} or \texttt{countreg::zerotrunc}) and the most general distributions, such as Generally Altered, Inflated, Truncated and Deflated, can be found in the \textbf{VGAM} package (e.g. \texttt{VGAM::gaitdpoisson} for the Poisson distribution, see @gaitdcount for a detailed description). However, the estimation of parameters of a given truncated (and possibly inflated) distribution is just the first step (as in the case of log-linear models in capture-recapture with two sources) and, to the best of our knowledge, there is no open-source software that can be used to estimate population size using on SSCR methods and includes variance estimators or diagnostics.

Therefore, the purpose of the \textbf{singleRcapture}, an \textbf{R} package, is to bridge this gap by providing scientists and other practitioners with a tool for estimating population size with SSCR methods. We have implemented state-of-the-art methods, as recently described by @bohning2018capture or @bohning2024one and provided their extensions (e.g., inclusion of covariates, different treatment of one-inflation), which will be covered in detail in Section \ref{sec-theory}. The package implements variance estimation based on various methods, can be used to create custom models and diagnostic plots (e.g. rootograms) with parameters estimated using a modified iteratively reweighted least squares (IRLS) algorithm we have implemented for estimation stability. To the best of our knowledge, no existing open-source package allows the estimation of population size by selecting an appropriate SSCR model, conducting the estimation, and providing informative diagnostics of the results.

The remaining part of the paper is structured as follows. Section \ref{sec-theory} contains a brief description of the theoretical background and information about fitting methods and available methods of variance estimation. Section \ref{sec-main} introduces the main functions of the package. Section \ref{sec-study} presents a case study and contains an assessment of its results, diagnostics and estimates of specific sub-populations. Section \ref{sec-methods} describes classes and \texttt{S3methods} implemented in the package. The paper ends with conclusions and an appendix showing how to use the \texttt{estimatePopsizeFit} function which is aimed to mimic the \texttt{glm.fit} or similar functions. In replication materials we show how to implement a custom model as this option could be of interest to users wishing to apply any new bootstrap methods not implemented in the package.

# Theoretical background {#sec-theory}

## How to estimate population size with a single source?

Let $Y_{k}$ represent the number of times the $k$-th unit was observed in a single source (e.g. register). Clearly, we only observe $k:Y_{k}>0$ and do not know how many units have been missed (i.e. $Y_{k}=0$), so the population size, denoted by $N$, needs to be estimated. In general, we assume that the conditional distribution of $Y_{k}$ given a vector of covariates $\bx_{k}$ follows a version of the zero-truncated count data distribution (and its extensions). When we know the parameters of the distribution we can estimate the population size using a Horvitz-Thompson type estimator given by:

\begin{equation}
\hat{N}=
\sum_{k=1}^{N}\frac{I_{k}}{\mathbb{P}[Y_{k}>0|\bX_{k}]}=
\sum_{k=1}^{N_{obs}}\frac{1}{\mathbb{P}[Y_{k}>0|\bX_{k}]},
\label{eq-ht-estimator}
\end{equation}

where $I_{k}:=\1_{\mathbb{N}}(Y_{k})$, $N_{obs}$ is the number of observed units and $\1$ is the indicator function, while the maximum likelihood estimate of $N$ is obtained after substituting regression parameters $\bbeta$ for $\mathbb{P}[Y_{k}>0|\bx_{k}]$ in \eqref{eq-ht-estimator}.

The basic SSCR assumes independence between counts, which is a rather naive assumption, since the first capture may significantly influence the behavior of a given unit or limit the possibility of subsequent captures (e.g. due to incarceration). 

To solve these issues, @godwin2017estimation and @ztoi-oizt-poisson introduced one-inflated distributions, which explicitly model the probability of singletons by giving additional mass $\omega$ to singletons denoted as $\1_{\{1\}}(y)$ [cf. @bohning2024one]. In other words they considered a new random varialbe $Y^{\ast}$ that corresponds to the data collection process which exhibits one inflation:

\begin{equation*}
  \mathbb{P}\left[Y^{\ast}=y|Y^{\ast}>0\right] =
  \omega\1_{\{1\}}(y)+(1-\omega)\mathbb{P}[Y=y|Y>0].
\end{equation*}

Analytic variance estimation is then performed by computing two parts of the decomposition according to the law of total variance given by:

\begin{equation}\label{eq-law_of_total_variance_decomposition}
  \text{var}[\hat{N}] = \mathbb{E}\left[\text{var}
  \left[\hat{N}|I_{1},\dots,I_{n}\right]\right] + 
  \text{var}\left[\mathbb{E}[\hat{N}|I_{1},\dots,I_{n}]\right],
\end{equation} 

where the first part can be estimated using the multivariate $\delta$ method given by:

\begin{equation*}
  \mathbb{E}\left[\text{var} \left[\hat{N}|I_{1},\dots,I_{n}\right]\right] =
  \left.\left(\frac{\partial(N|I_1,\dots,I_N)}{\partial\bbeta}\right)^\top
  \text{cov}\left[\hat{\bbeta}\right]
  \left(\frac{\partial(N|I_1,\dots,I_N)}{\partial\bbeta}\right)
  \right|_{\bbeta=\hat{\bbeta}},
\end{equation*}

while the second part of the decomposition in \eqref{eq-law_of_total_variance_decomposition}, assuming independence of $I_{k}$'s and after some omitted simplifications, is optimally estimated by:

\begin{equation*}
  \text{var}\left[\mathbb{E}(\hat{N}|I_{1},\dots,I_{n})\right] =
  \text{var}\left[\sum_{k=1}^{N}\frac{I_{k}}{\mathbb{P}(Y_{k}>0)}\right]
  \approx\sum_{k=1}^{N_{obs}}\frac{1-\mathbb{P}(Y_{k}>0)}{\mathbb{P}(Y_{k}>0)^{2}},
\end{equation*}

which serves as the basis for interval estimation. Confidence intervals are usually constructed under the assumption of (asymptotic) normality of $\hat{N}$ or asymptotic normality of $\ln(\hat{N}-N)$ (or log normality of $\hat{N}$). The latter is an attempt to address a common criticism of student type confidence intervals in SSCR, namely a possibly skewed distribution of $\hat{N}$, and results in the $1-\alpha$ confidence interval given by:

\begin{equation*}
  \left(N_{obs}+\frac{\hat{N}-N_{obs}}{\xi},N_{obs} +
  \left(\hat{N}-N_{obs}\right)\xi\right),
\end{equation*}

where:

\begin{equation*}
  \xi = \exp\left(z\left(1-\frac{\alpha}{2}\right)
  \sqrt{\ln\left(1+\frac{\widehat{\text{Var}}(\hat{N})}{\left(\hat{N}-N_{obs}\right)^{2}}\right)}\right),
\end{equation*}

and where $z$ is the quantile function of the standard normal distribution. The estimator $\hat{N}$ is best interpreted as being an estimator of the total number of \underline{observable} units in the population, since we have no means of estimating the number of units in the population for which the probability of being included in the data is $0$ \citep[cf.][]{ztpoisson}.

## Available models

The full list of models implemented in \textbf{singleRcapture} along with corresponding expressions for probability density functions and point estimates can be found in the collective help file for all family functions:

```{r, eval=FALSE}
?ztpoisson
```

For the sake of simplicity, we only list the family functions together with brief descriptions. For more detailed information, please consult the relevant literature.

The current list of these family functions includes:

\begin{itemize}
    \item Generalized Chao's \citep{chao1987estimating} and Zelterman's \citep{zelterman1988robust} estimators via logistic regression on variable $Z$ defined as $Z=1$ if $Y=2$ and $Z=0$ if $Y=1$ with $Z\sim b(p)$ where $b(\cdot)$ is the Bernoulli distribution and $p$ can be modeled for each unit $k$ by $\text{logit}(p_k)=\ln(\lambda_k/2)$ with Poisson parameter $\lambda_k=\bx_{k}\bbeta$ (for a covariate extension see \cite{chao-generalization} and \cite{zelterman}):
    \begin{align}
        \hat{N}_{\text{Chao}} &= N_{obs}+
        \sum_{k=1}^{\boldsymbol{f}_{1}+\boldsymbol{f}_{2}}
        \left(2\exp\left(\bx_{k}\hat{\bbeta}\right)+
        2\exp\left(2\bx_{k}\hat{\bbeta}\right)\right)^{-1},
        \tag{\text{Chao's estimator}}\\
        \hat{N}_{\text{Zelt}}&=\sum_{k=1}^{N_{obs}}
        \left(1-\exp\left(-2\exp\left(\bx_{k}\hat{\bbeta}\right)\right)\right)^{-1}.
        \tag{\text{Zelterman's estimator}}
    \end{align}
    where $\boldsymbol{f}_{1}$ and $\boldsymbol{f}_{2}$ denotes number of units observed once and twice.
    \item Zero-truncated (\texttt{zt}$^\ast$) and zero-one-truncated (\texttt{zot}$^\ast$) Poisson \citep[cf. ][]{zotmodels}, geometric, NB type II (NB2) regression, where the non-truncated distribution is parameterized as:
    \begin{equation*}
        \mathbb{P}[Y=y|\lambda,\alpha] = \frac{\Gamma\left(y+\alpha^{-1}\right)}{\Gamma\left(\alpha^{-1}\right)y!}
        \left(\frac{\alpha^{-1}}{\alpha^{-1}+\lambda}\right)^{\alpha^{-1}}
        \left(\frac{\lambda}{\lambda + \alpha^{-1}}\right)^{y}.
    \end{equation*}
    \item Zero-truncated one-inflated (\texttt{ztoi}$^\ast$) modifications, where the count data variable $Y^{\ast}$ is defined such that its distribution statisfies:
    \begin{equation*}
    \mathbb{P}\left[Y^{\ast}=y\right]=
    \begin{cases}
    \mathbb{P}[Y=0] & y=0, \\
    \omega\left(1-\mathbb{P}[Y=0]\right)+(1-\omega)\mathbb{P}[Y=1] & y=1, \\
    (1-\omega)\mathbb{P}[Y=y] & y>1,
    \end{cases}
    \end{equation*}
    \begin{equation*}
        \mathbb{P}\left[Y^{\ast}=y|Y^{\ast}>0\right]=\omega\1_{\{1\}}(y)+(1-\omega)\mathbb{P}[Y=y|Y>0].
    \end{equation*}
    \item One-inflated zero-truncated (\texttt{oizt}$^\ast$) modifications, where the count data variable $Y^{\ast}$ is defined as:
    \begin{equation*}
        \mathbb{P}\left[Y^{\ast}=y\right] = \omega \1_{\{1\}}(y)+(1-\omega)\mathbb{P}[Y=y],
    \end{equation*}
    \begin{equation*}
        \mathbb{P}\left[Y^{\ast}=y|Y^{\ast}>0\right] = 
        \omega\frac{\1_{\{1\}}(y)}{1-(1-\omega)\mathbb{P}[Y=0]}+
        (1-\omega)\frac{\mathbb{P}[Y=y]}{1-(1-\omega)\mathbb{P}[Y=0]}.
    \end{equation*}
    Note that \texttt{ztoi}$^\ast$ and \texttt{oizt}$^\ast$ distributions are equivalent, in the sense that the maximum value of the likelihood function is equal for both of those distributions given any data, as shown by \cite{bohning2023equivalence} but population size estimators are different.
\end{itemize}
    
In addition, we propose two new approaches to model singletons in a similar way as in hurdle models. In particular, we have proposed the following:

\begin{itemize}
    \item The zero-truncated hurdle model (\texttt{ztHurdle}$^\ast$) for Poisson, geometric and NB2 is defined as:
    \begin{equation*}
        \mathbb{P}\left[Y^{\ast}=y\right]=\begin{cases}
        \frac{\mathbb{P}[Y=0]}{1-\mathbb{P}[Y=1]} & y=0, \\
        \pi(1-\mathbb{P}[Y=1]) & y=1, \\
        (1-\pi) \frac{\mathbb{P}[Y=y]}{1-\mathbb{P}[Y=1]} & y>1,
        \end{cases}
    \end{equation*}
    \begin{equation*}
        \mathbb{P}\left[Y^{\ast}=y|Y^{\ast}>0\right]=\pi\1_{\{1\}}(y)+
        (1-\pi)\1_{\mathbb{N}\setminus\{1\}}(y)\frac{\mathbb{P}[Y=y]}{1-\mathbb{P}[Y=0]-\mathbb{P}[Y=1]}.
    \end{equation*}
    where $\pi$ denotes the conditional probability of observing singletons.
    \item The hurdle zero-truncated model (\texttt{Hurdlezt}$^\ast$) for Poisson, geometric and NB2 is defined as:
    \begin{align*}
        \mathbb{P}\left[Y^{\ast}=y\right]&=\begin{cases}
        \pi & y=1, \\
        (1-\pi) \frac{\mathbb{P}[Y=y]}{1-\mathbb{P}[Y=1]} & y\neq1,
        \end{cases}\\
        \mathbb{P}\left[Y^{\ast}=y|Y^{\ast}>0\right]&=\begin{cases}
            \pi\frac{1-\mathbb{P}[Y=1]}{1-\mathbb{P}[Y=0]-\mathbb{P}[Y=1]} & y=1,\\
            (1-\pi)\frac{\mathbb{P}[Y=y]}{1-\mathbb{P}[Y=0]-\mathbb{P}[Y=1]} & y>1,
        \end{cases}
    \end{align*}
    where $\pi$ denotes the unconditional probability of observing singletons.
\end{itemize}

The approaches presented above differ in their assumptions, computational complexity, or in the way they treat heterogeneity of captures and singletons. For instance, the dispersion parameter $\alpha$ in the NB2 type models is often interpreted as measuring the \textit{severity} of unobserved heterogeneity in the underlying Poisson process \citep[cf.][]{ztnegbin}. When using any truncated NB model, the hope is that given the class of models considered, the consistency is not lost despite the lack of information.

While not discussed in the literature, the interpretation of heterogeneous $\alpha$ across the population (specified in \texttt{controlModel}) would be that the unobserved heterogeneity affects the accuracy of the prediction for the dependent variable $Y$ more severely than others. The geometric model (NB with $\alpha=1$) is singled out in the package and often considered in the literature because of inherent computational issues with NB models, which are exacerbated by the fact that data used for SSCR are usually of rather low quality. Data sparsity is a particularly common problem in SSCR and a big challenge for all numerical methods for fitting the (zero-truncated) NB model.

The extra mass $\omega$ in one-inflated models is an important extension to the researcher's toolbox for SSCR models, since the inflation at $y=1$ is likely to occur in many types of applications. For example, when estimating the number of active people who committed criminal acts in a given time period, the fact of being captured for the first time following an arrest is associated with the risk of no longer being able to be captured a second time. One constraint present in modelling via inflated models is that attempts to include both the possibility of one inflation and one deflation lead to both numerical and inferential problems since the parameter space (of $(\omega, \lambda)$ or $(\omega, \lambda, \alpha)$) is then given by $\{(\omega, \lambda, \alpha) | \forall x\in \mathbb{N}: p(x|\omega, \lambda, \alpha)\geq0\}$ for the probability mass function $p$. The boundary of this set is then a $1$ or $2-$dimentional manifold, transforming this parameter space into $\mathbb{R}^{3}$ would require using "link" functions that depend on more than one parameter.

Hurdle models represent another approach to modelling one-inflation. They can also model deflation as well as inflation and deflation simultaneously, so they are more flexible and, in the case of hurdle zero-truncated models, appear to be more numerically stable.

Although the question of how to interpret regression parameters tends to be somewhat overlooked in SSCR studies, we should point out that the interpretation of the $\omega$ inflation parameter (in \texttt{ztoi}$^\ast$ or \texttt{oizt}$^\ast$) is more convenient than the interpretation of the $\pi$ probability parameter (in hurdle models). Additionally, the interpretation of the $\lambda$ parameter in (one) inflated models conforms to the following intuition: given that unit $k$ comes from the non-inflated part of the population, it follows a Poisson distribution (respectively geometric or negative binomial) with the $\lambda$ parameter (or $\lambda,\alpha$); no such interpretation exists for hurdle models. Interestingly, estimates from hurdle zero-truncated and one-inflated zero-truncated models tend to be quite close to one another, although more rigorous studies are required to confirm this observation.

## Fitting method

As previously noted, the \textbf{singleRcapture} package can be used to model the (linear) dependence of all parameters on covariates. A modified IRLS algorithm is employed for this purpose as presented in Algorithm \ref{algo-estimation}; full details are available in \cite{VGAM-main}. In order to apply the algorithm, a modified model matrix $\bX_{\text{vlm}}$ is created when the \texttt{estimatePopsize} function is called. In the context of the models implemented in \textbf{singleRcapture}, this matrix can be written as: 

\begin{equation}\label{X_vlm-definition}
  \bX_{\text{vlm}}=
  \begin{pmatrix}
    \bX_{1} & \bZero &\dotso &\bZero\cr
    \bZero & \bX_{2} &\dotso &\bZero\cr
    \vdots & \vdots & \ddots & \vdots\cr
    \bZero & \bZero &\dotso &\bX_{p}
  \end{pmatrix}
\end{equation} 

where each $\bX_{i}$ corresponds to a model matrix associated with a user specified formula.


\begin{algorithm}[ht!]
\small
\caption{The modified IRLS algorithm used in the \textbf{singleRcapture} package}
\label{algo-estimation}\DontPrintSemicolon
\nlset{1} Initialize with \texttt{iter}$\leftarrow 1, \boeta\leftarrow$\texttt{start}
    $, \bW\leftarrow I, \ell\leftarrow\ell(\bbeta)$.\;
\nlset{2} Store values from the previous step: 
    $\ell_{-}\leftarrow\ell, \bW_{-}\leftarrow\bW, \bbeta_{-}\leftarrow\bbeta$ 
    (the last assignment is omitted during the first iteration), and assign values in the current iteration 
    $\displaystyle\boeta\leftarrow\bX_{\text{vlm}}\bbeta+\bo, \bW_{(k)}\leftarrow\mathbb{E}\left[-\frac{\partial^{2}\ell}{\partial\boeta_{(k)}^\top\partial\boeta_{(k)}}\right], \boldsymbol{Z}_{(k)}\leftarrow\boeta_{(k)}+\frac{\partial\ell}{\partial\boeta_{(k)}}\bW_{(k)}^{-1}-\bo_{(k)}$,\;
    where $\bo$ denotes offset.\;
\nlset{3} Assign the current coefficient value: 
    $\bbeta\leftarrow\left(\bX_{\text{vlm}}\bW\bX_{\text{vlm}}\right)^{-1}\bX_{\text{vlm}}\bW\boldsymbol{Z}$.\;
\nlset{4} If $\ell(\bbeta)<\ell(\bbeta_{-})$ try selecting the smallest value $h$ such that for
    $\bbeta_{h}\leftarrow2^{-h}\left(\bbeta+\bbeta_{-}\right)$ the inequality $\ell(\bbeta_{h})>\ell(\bbeta_{-})$
    holds if this is successful $\bbeta\leftarrow\bbeta_{h}$, else stop the algorithm.\;
\nlset{5} If convergence is achieved or \texttt{iter} is higher than \texttt{maxiter}, stop the algorithm, 
    else \texttt{iter}$\leftarrow 1+$\texttt{iter} and return to step 2.
\end{algorithm}

In the case of multi-parameter families, we get a matrix of linear predictors $\boeta$ instead of a vector, with the number of columns matching the number of parameters in the distribution. "Weights" (matrix $\bW$) are then modified to be information matrices $\displaystyle\mathbb{E}\left[-\frac{\partial^{2}\ell}{\partial\boeta_{(k)}^\top\partial\boeta_{(k)}}\right]$, where $\ell$ is the log-likelihood function and $\boeta_{(k)}$ is the $k$-th row of $\boeta$, while in the typical IRLS they are scalars $\displaystyle\mathbb{E}\left[-\frac{\partial^{2}\ell}{\partial\eta_{k}^{2}}\right]$, which is often just
$\displaystyle-\frac{\partial^{2}\ell}{\partial\eta^{2}}$. 


## Bootstrap variance estimators {#sec-boostrap}

We have implemented three types of bootstrap algorithms: parametric (adapted from theory in \cite{zwane}, \cite{norrpoll} for multiple source setting with covariates), semi-parametric (see e.g. \cite{BoehningFriedl2021}) and nonparametric. The nonparametric version is the usual bootstrap algorithm; which will typically underestimate the variance of $\hat{N}$. In this section, the focus is on the first two approaches.

The idea of semi-parametric bootstrap is to modify the usual bootstrap to include the additional uncertainty resulting from the fact that the sample size is a random variable. This type of bootstrap is performed in steps listed in Algorithm \ref{algo-semipar-boot}.

\begin{algorithm}[ht!]
\small
\caption{Semi-parametric bootstrap}
\label{algo-semipar-boot}\DontPrintSemicolon
\nlset{1} Draw a sample of size $N_{obs}'\sim\text{Binomial}\left(N', \frac{N_{obs}}{N'}\right)$, where $N'=\lfloor\hat{N}\rfloor+\text{Bernoulli}\left(\lfloor\hat{N}\rfloor-\hat{N}\right)$.\;
\nlset{2} Draw $N_{obs}'$ units from the data uniformly without replacement.\;
\nlset{3} Obtain a new population size estimate $N_b$ using bootstrap data.\;
\nlset{4} Repeat $1-3$ steps $B$ times.
\end{algorithm}

In other words, we first draw a sample size and then a sample conditional on the sample size. Note that when using the semi-parametric bootstrap one implicitly assumes that the population size estimate $\hat{N}$ is accurate. The last implemented bootstrap type is the parametric algorithm, which first draws a finite population of size $\approx\hat{N}$ from the superpopulation model and then samples from this population according to the selected model, as described in Algorithm \ref{algo-par-boot}.

\begin{algorithm}[ht!]
\small
\caption{Parametric bootstrap}
\label{algo-par-boot}\DontPrintSemicolon
\nlset{1} Draw the number of covariates equal to $\lfloor\hat{N}\rfloor+\text{Bernoulli}\left(\lfloor\hat{N}\rfloor-\hat{N}\right)$ proportional to the estimated contribution $(\mathbb{P}\left[Y_{k}>0|\bx_{k}\right])^{-1}$ with replacement.\;
\nlset{2} Using the fitted model and regression coefficients $\hat{\bbeta}$ draw for each covariate the $Y$ value from the corresponding probability measure on $\mathbb{N}\cup\{0\}$.\;
\nlset{3} Truncate units with the drawn $Y$ value equal to $0$.\;
\nlset{4} Obtain a population size estimate $N_b$ based on the truncated data.\;
\nlset{5} Repeat $1-4$ steps $B$ times.
\end{algorithm}

Note that in order for this type of algorithm to result in consistent standard error estimates, it is imperative that the estimated model for the entire superpopulation probability space is consistent, which may be much less realistic than in the case of the semi-parametric bootstrap. The parametric bootstrap algorithm is the default option in \textbf{singleRcapture}.


# The main function {#sec-main}

\subsection[The estimatePopsize function]{The \texttt{estimatePopsize} function}

The \textbf{singleRcapture} package is built around the \texttt{estimatePopsize} function. The main design objective was to make using \texttt{estimatePopsize} as similar as possible to the standard \texttt{stats::glm} function or packages for fitting zero-truncated regression models, such as \textbf{countreg} (e.g. \texttt{countreg::zerotrunc} function). 
The \texttt{estimatePopsize} function is used to first fit an appropriate (vector) generalized linear model and to estimate the population size along with its variance. It is assumed that the response vector (i.e. the dependent variable) corresponds to the number of times a given unit was observed in the source. The most important arguments are given in Table \ref{tab-arguments-popsize}; the obligatory ones are \texttt{formula, data, model}.

\begin{table}[ht!]
\centering
\begin{tabular}{p{3cm}p{11cm}}
\hline
Argument & Description \\
\hline
\texttt{formula} & The main formula (i.e for the Poisson $\lambda$ parameter); \\
\texttt{data} & a \texttt{data.frame} (or \texttt{data.frame} coercible) object; \\
\texttt{model} & either a function a string or a family class object specifying which model should be used; possible values are listed in the documentation. The supplied argument should have the form \texttt{model =  "ztpoisson"}, \texttt{model = ztpoisson}, or if a link function should be specified, then \texttt{model = ztpoisson(lambdaLink = "log")} can be used; \\
\texttt{method} & a numerical method used to fit regression \texttt{IRLS} or \texttt{optim}; \\
\texttt{popVar} & a method for estimating variance of $\hat{N}$ and creating confidence intervals (either bootstrap, analytic or skipping the estimation entirely); \\
\texttt{controlMethod}, \texttt{controlModel} or \texttt{controlPopVar} & control parameters for numerical fitting, specifying additional formulas (inflation, dispersion) and population size estimation, respectively; \\
\texttt{offset} &  a matrix of offset values with the number of columns matching the number of distribution parameters providing offset values to each of linear predictors;\\
\texttt{...} & additional optional arguments passed to other methods eg. \texttt{estimatePopsizeFit}; \\
\hline
\end{tabular}
\caption{A description of \texttt{estimatePopsize} function arguments}
\label{tab-arguments-popsize}
\end{table}

An important step in using \texttt{estimatePopsize} is specifying the \texttt{model} parameter, which indicates the type of model that will be used for estimating the *unobserved* part of the population. For instance, to fit Chao's or Zelterman's model one should select \texttt{chao} or \texttt{zelterman} and, assuming that one-inflation is present, one can select one of the zero-truncated one-inflated (\texttt{ztoi}$^\ast$) or one-inflated zero-truncated (\texttt{oizt}$^\ast$) models, such as \texttt{oiztpoisson} for Poisson or \texttt{ztoinegbin} for NB2.

If it is assumed that heterogeneity is observed for NB2 models, one can specify the formula in the \texttt{controlModel} argument with the \texttt{controlModel} function and the \texttt{alphaFormula} argument. This enables the user to provide a formula for the dispersion parameter in the NB2 models. If heterogeneity is assumed for \texttt{ztoi}$^\ast$ or \texttt{oizt}$^\ast$, one can specify the \texttt{omegaFormula} argument, which corresponds to the $\omega$ parameter in these models. Finally, if covariates are assumed to be available for the hurdle models (\texttt{ztHurdle}$^\ast$ or \texttt{Hurdlezt}$^\ast$), then \texttt{piFormula} can be specified, as it provides a formula for the probability parameter in these models. 


\subsection[Controlling variance estimation with controlPopVar]{Controlling variance estimation with \texttt{controlPopVar}}

The \texttt{estimatePopsize} function makes it possible to specify the variance estimation method via \texttt{popVar} (e.g. analytic or variance bootstrap) and control the estimation process by specifying \texttt{controlPopVar}. In the control function \texttt{controlPopVar} the user can specify the \texttt{bootType} argument, which has
three possible values: \texttt{"parametric", "semiparametric"} and \texttt{"nonparametric"}. Additional arguments accepted by the \texttt{contorlPopVar} function, which are relevant to bootstrap, include:

\begin{itemize}
  \item \texttt{alpha}, \texttt{B} -- the significance level and the number of bootstrap samples to be performed, respectively, with $0.05$ and $500$ being the default options.
  \item \texttt{cores} -- the number of process cores to be used in bootstrap (1 by default); parallel computing is enabled by \textbf{doParallel} \citep{doParallel}, \textbf{foreach} \citep{foreach} and \textbf{parallel} packages \citep{parallel}.
  \item \texttt{keepbootStat} -- a logical value indicating whether to keep a vector of statistics produced by the bootstrap.
  \item \texttt{traceBootstrapSize}, \texttt{bootstrapVisualTrace} --  logical values indicating whether sample and population size should be tracked (\texttt{FALSE} by default); these work only when \texttt{cores} = 1.
    \item \texttt{fittingMethod}, \texttt{bootstrapFitcontrol} -- the fitting method (by default the same as the one used in the original call) and control parameters (\texttt{controlMethod}) for model fitting in the bootstrap.
\end{itemize}

In addition, the user can specify the type of confidence interval by means of \texttt{confType} and the type of covariance matrix by using \texttt{covType} for the analytical variance estimator (observed or the Fisher information matrix).

In the next sections we present a case study involving the use of a simple zero-truncated Poisson regression and a more advanced model: one-inflated zero-truncated geometric regression with the \texttt{cloglog} link function. First, we present the example dataset, then we describe how to estimate the population size and assess the quality and diagnostics measures. Finally, we show how to estimate the population size in user-specified sub-populations.

# Data analysis example {#sec-study}

The package can be installed in the standard manner using:

```{r, installation, eval=FALSE}
install.packages("singleRcapture")
```

Then, we need to load the package using the following code:

```{r, loading-package, warning=FALSE}
library(singleRcapture)
```

## Dataset 

We use a dataset from \cite{ztpoisson}, which contains information about immigrants in four Dutch cities
(Amsterdam, Rotterdam, The Hague and Utrecht), who were staying in the country without a legal permit in 1995 and appeared in police records for that year. This dataset is included in the package called \texttt{netherlandsimmigrant}:

```{r, loading_singleRcapture}
data(netherlandsimmigrant)
head(netherlandsimmigrant)
```


The number of times each individual appeared in the records is included in the \texttt{capture} variable. The
available covariates include \texttt{gender, age, reason, nation}; the last two represent the reason for being captured and the region of the world a given person comes from:

```{r, netherlandsimmigrant_summary}
summary(netherlandsimmigrant)
```

One notable characteristic of this dataset is that it contains a disproportionately large number of individuals who were observed only once (i.e. `r sum(netherlandsimmigrant$capture==1)`).

```{r, table_netherlands}
table(netherlandsimmigrant$capture)
```

The basic syntax of \texttt{estimatePopsize} is very similar to that of \texttt{glm}, the same can be said about the output of the summary method except for additional results of population size estimates (denoted as \texttt{Population size estimation results}).

```{r, basic_model_netherlands}
basicModel <- estimatePopsize(
  formula = capture ~ gender + age + nation,
  model   = ztpoisson(),
  data    = netherlandsimmigrant,
  controlMethod = controlMethod(silent = TRUE)
)
summary(basicModel)
```

The output regarding the population size contains the point estimate, the observed proportion (based on the input dataset), the standard error and two confidence intervals: one relating to the point estimate, the second -- to the observed proportion. 

According to this simple model, the population size is about 12,500, with about 15% of units observed in the register. The 95% CI under normality indicates that the true population size is likely to be between 7,000-18,000, with about 10-26% of the target population observed in the register.

Since there is a reasonable suspicion that the act of observing a unit in the dataset may lead to undesirable consequences for the person concerned (in this case, a possible deportation, detention or something similar). For these reasons, the user may consider one-inflated models, such as one-inflated zero-truncated geometric model (specified by \texttt{oiztgeom} family) and those presented below.

```{r, model_inflated_netherlands, warning=FALSE, cache=T}
set.seed(123456)
modelInflated <- estimatePopsize(
    formula = capture ~ nation,
    model   = oiztgeom(omegaLink = "cloglog"),
    data    = netherlandsimmigrant,
    controlModel = controlModel(
        omegaFormula = ~ gender + age
    ),
    popVar = "bootstrap",
    controlPopVar = controlPopVar(bootType = "semiparametric")
)
summary(modelInflated)
```

According to this approach, the population size is about 7,000, which is about 5,000 less than in the case of the naive Poisson approach. A comparison of AIC and BIC suggests that the one-inflation model fits the data better with BIC for \texttt{oiztgeom} `r round(BIC(modelInflated))` and `r round(BIC(basicModel))` for \texttt{ztpoisson}. 

We can access population size estimates using the following code, which returns a list with numerical results.

```{r, extract_pop_size}
popSizeEst(basicModel)    # alternative: basicModel$populationSize
popSizeEst(modelInflated) # alternative: modelInflated$populationSize
```

The decision whether to use a zero-truncated Poisson or one-inflated zero-truncated geometric model should be based on the assessment of the model and the assumptions regarding the data generation process. One possible method of selection is based on the likelihood ratio test, which can be computed quickly and conveniently with the \textbf{lmtest} (@lmtest) interface:

```{r, message=FALSE}
library(lmtest)
```

```{r}
lrtest(basicModel, modelInflated, 
       name = function(x) {
    if (family(x)$family == "ztpoisson")
        "Basic model"
    else "Inflated model"
})
```
However, the above is not a standard method of model selection in SSCR. The next sections are dedicated to a  detailed description of how to assess the results using standard statistical tests and diagnostics.

## Testing marginal frequencies

A popular method of testing the model fit in single source capture-recapture studies consists in comparing the fitted marginal frequencies $\displaystyle\sum_{j=1}^{N_{obs}}\hat{\mathbb{P}}\left[Y_{j}=k|\bx_{j}, Y_{j} > 0\right]$ with the observed marginal frequencies $\displaystyle\sum_{j=1}^{N}\1_{\{k\}}(Y_{j})=\sum_{j=1}^{N_{obs}}\1_{\{k\}}(Y_{j})$ for $k\geq1$. If the fitted model bears sufficient resemblance to the real data collection process, these quantities should be quite close and both $G$ and $\chi^{2}$ tests can be used to test the statistical significance of the discrepancy with the following \textbf{singleRcapture} syntax for the Poisson model (rather poor fit):

```{r, marginal_freq_basic_model}
margFreq <- marginalFreq(basicModel)
summary(margFreq, df = 1, dropl5 = "group")
```

and for the one-inflated model (better fit):

```{r, marginal_freq_inflated_model}
margFreq_inf <- marginalFreq(modelInflated)
summary(margFreq_inf, df = 1, dropl5 = "group")
```

where the \texttt{dropl5} argument is used to indicate how to handle cells with less than $5$ fitted observations. Note, however, that currently there is no continuity correction. 

## Diagnostics

The \texttt{singleRStaticCountData} class has a \texttt{plot} method implementing several types of quick demonstrative plots, such as the rootogram \citep[cf.][]{rootogram}, for comparing fitted and marginal
frequencies, which can be generated with the following syntax:

```{r, rootogram, fig.pos="ht", fig.show='hold', out.width="7.5cm", fig.cap="Rootograms for ztpoisson (left) and oiztgeom (right) models"}
plot(   basicModel, plotType = "rootogram", main = "ZT Poisson model")
plot(modelInflated, plotType = "rootogram", main = "OI ZT Geometric model")
```

```{r, dev_off-1, include=FALSE}
dev.off()
```

The above plots suggest that the \texttt{oiztgeom} model fits the data better. Another important issue in population size estimation is to conduct model diagnostics in order to verify whether influential observations are present in the data. For this purpose the leave-one-out (LOO) diagnostic implemented in the \texttt{dfbeta} from the \textbf{stats} package has been adapted as shown below (multiplied by a factor of a hundred for better readability):

```{r, dfbeta_basic_model}
dfb <- dfbeta(basicModel)
round(t(apply(dfb, 2, quantile)*100), 4)
```

```{r, df_beta_inflated_model}
dfi <- dfbeta(modelInflated)
round(t(apply(dfi, 2, quantile)*100), 4)
```

The result of the \texttt{dfbeta} can be further used in the \texttt{dfpopsize} function, which can be used to quantify LOO on the population size. Note the warning when the bootstap variance estimation is applied.

```{r, dfpopsize_basic_model}
dfb_pop <- dfpopsize(basicModel, dfbeta = dfb)
dfi_pop <- dfpopsize(modelInflated, dfbeta = dfi)
summary(dfb_pop)
summary(dfi_pop)
```

Figure 2 shows a comparison of the effect of deleting an observation on the population size estimate and inverse probability weights, which refer to the contribution of a given observation to the population size estimate:

```{r, dfpopsize_plot, fig.pos="ht", fig.show='hold', out.width="7.5cm", fig.cap="Results for ztpoisson (left) and oiztgeom (right) model"}
plot(basicModel, plotType = "dfpopContr", 
     dfpop = dfb_pop, xlim = c(-4500, 150))
plot(modelInflated, plotType = "dfpopContr", 
     dfpop = dfi_pop, xlim = c(-4500, 150))
```

```{r, dev_off-2, include=FALSE}
dev.off()
```

These plots show how the population size changes if a given observation is removed. For instance, if we remove observation `r which.min(dfb_pop)`, then the population size will increase by about `r abs(round(min(dfb_pop)))` for the \texttt{ztpoisson} model. In the case of \texttt{oiztgeom}, the largest change is equal to `r abs(round(min(dfi_pop)))` for observation `r which.min(dfi_pop)`.

The full list of plot types along with the list of optional arguments that can be passed from the call to the \texttt{plot} method down to base \textbf{R} and \textbf{graphics} functions can be found in the help file of the \texttt{plot} method.

```{r, eval=FALSE}
?plot.singleRStaticCountData
```

\subsection[The stratifyPopsize function]{The \texttt{stratifyPopsize} function}

Researchers may be interested not only in the total population size but also in the size of specific sub-populations (e.g. males, females, particular age groups). For this reason we have created the \texttt{stratifyPopsize} function, which estimates the size by strata defined by the coefficients in the model (the default option). The following output presents results based on the \texttt{ztpoisson} and \texttt{oiztgeom} models.

```{r, strata}
popSizestrata <- stratifyPopsize(basicModel)
cols <- c("name", "Observed", "Estimated", "logNormalLowerBound", 
          "logNormalUpperBound")
popSizestrata_report <- popSizestrata[, cols]
cols_custom <- c("Name", "Obs", "Estimated", "LowerBound", "UpperBound")
names(popSizestrata_report) <- cols_custom
popSizestrata_report
```

```{r, strata-inflated}
popSizestrata_inflated <- stratifyPopsize(modelInflated)
popSizestrata_inflated_report <- popSizestrata_inflated[, cols]
names(popSizestrata_inflated_report) <- cols_custom
popSizestrata_inflated_report
```

The \texttt{stratifyPopsize} function prepared to handle objects of the \texttt{singleRStaticCountData} class, accepts three optional parameters \texttt{strata, alpha, cov}, which are used for specifying sub-populations, significance levels and the covariance matrix to be used for computing standard errors. An example of the full call is presented below.


```{r, custom-strata, message=F, warning=F}
library(sandwich)
popSizestrataCustom <- stratifyPopsize(
  object  = basicModel,
  strata = ~ gender + age, 
  alpha   = rep(c(0.1, 0.05), each=2), 
  cov     = vcovHC(basicModel, type = "HC4")
)

popSizestrataCustom_report <- popSizestrataCustom[, c(cols, "confLevel")]
names(popSizestrataCustom_report) <- c(cols_custom, "alpha")
popSizestrataCustom_report
```

We have provided integration with the \textbf{sandwich} \citep{sandwich} package to correct the variance-covariance matrix in the $\delta$ method. In the code we have used the \texttt{vcovHC} method for \texttt{singleRStaticCountData} class from the \textbf{sandwich} package, different significance levels
for confidence intervals in each stratum and a formula to specify that we want estimates for both males and females to be grouped by \texttt{nation} and \texttt{age}. The \texttt{strata} parameter can be specified either as:

\begin{itemize}
\item a formula with the empty left hand side, as shown in the example above (e.g. \texttt{~ gender * age}),
\item a logical vector with the number of entries equal to the number of rows in the dataset, in which case only one stratum will be created (e.g. \texttt{netherlandsimmigrant$gender == "male"}),
\item a vector of names of explanatory variables, which will result in every level of the explanatory variable having its own sub-population for each variable specified (e.g. \texttt{c("gender", "age")}),
\item not supplied at all, in which case strata will correspond to levels of each factor in the data without any interactions (string vectors will be converted to factors for the convenience of the user),
\item a (named) list where each element is a logical vector; names of the list will be used to specify variable names in the returned object, for example:
\end{itemize}
```{r, eval=FALSE}
list(
  "Stratum 1" = netherlandsimmigrant$gender == "male"   & 
    netherlandsimmigrant$nation == "Suriname", 
  "Stratum 2" = netherlandsimmigrant$gender == "female" & 
    netherlandsimmigrant$nation == "North Africa"
)
```

One can also specify \texttt{plotType = "strata"} in the \texttt{plot} function, which results in a plot with point and CI estimates of the population size.

```{r, strata_plot, fig.show='hold', out.width="7.5cm", fig.pos = "ht", fig.cap="Population size by covariates for ztpoisson (left) and oiztgeom (right) model"}
par(mar = c(2.5, 8.5, 4.1, 2.5), cex.main = .7, cex.lab = .6)
plot(basicModel, plotType = "strata")
plot(modelInflated, plotType = "strata")
```

```{r, dev_off-3, include=FALSE}
dev.off()
```

Only the \texttt{logNormal} type of confidence interval is used for plotting since the studentized confidence intervals often result in negative lower bounds.

\section[Classes and S3Methods]{Classes and \texttt{S3Methods}}\label{sec-methods}

We have created a number of classes. The main ones are: \texttt{singleRStaticCountData}, \texttt{singleRfamily}, and supplementary are: \texttt{popSizeEstResults}, \texttt{summarysingleRmargin} and \newline \texttt{summarysingleRStaticCountData}, which make it possible to extract relevant information regarding the population size. 

For instance, the \texttt{popSizeEst} function can be used to extract information about the estimated size of the population as given below:

```{r, popsize_extract}
(popEst <- popSizeEst(basicModel))
```

and the resulting object \texttt{popEst} of the \texttt{popSizeEstResults} class contains the following fields:

\begin{itemize}
  \item \texttt{pointEstimate}, \texttt{variance} -- numerics containing the point estimate and variance of this estimate.
  \item \texttt{confidenceInterval} -- a \texttt{data.frame} with confidence intervals.
  \item \texttt{boot} -- If the bootstrap was performed a numeric vector containing the $\hat{N}$ values from the bootstrap, a character vector with value \texttt{"No bootstrap performed"} otherwise.
  \item \texttt{control} -- a \texttt{controlPopVar} object with controls used to obtain the object.
\end{itemize}

The only explicitly defined method for \texttt{popSizeEstResults}, \texttt{summarysingleRmargin} and \texttt{summarysingleRStaticCountData} classes is the \texttt{print} method, but the former one also accepts \textbf{R} primitives like \texttt{coef}:

```{r, extract-coefs}
coef(summary(basicModel))
```

analogously to \texttt{glm} from \textbf{stats}. The \texttt{singleRfamily} inherits the \texttt{family} class from \textbf{stats} and has explicitly defined \texttt{print} and \texttt{simulate} methods. Example usage is presented below

\begin{table}[ht!]
\centering
\small
\begin{tabular}{p{4cm}p{11cm}}
\hline 
Function & Description \\
\hline
\texttt{fitted} & it works almost exactly like \texttt{glm} counterparts but returns more information, namely on fitted values for the truncated and non-truncated probability distribution; \\
\texttt{logLik} & compared to \texttt{glm} method, it has the possibility of returning not just the value of the fitted log-likelihood but also the entire function (argument \texttt{type = "function"}) along with two first derivatives (argument \texttt{deriv = 0:2}); \\
\texttt{model.matrix} & it has the possibility of returning the $X_{\text{vlm}}$ matrix defined in \ref{X_vlm-definition};\\
\texttt{simulate} & it calls the \texttt{simulate} method for the chosen model and fitted $\boeta$; \\
\texttt{predict} &  it has the possibility of returning either fitted distribution parameters for each unit (\texttt{type = "response"}), or just linear predictors (\texttt{type = "link"}), or means of the fitted distributions of $Y$ and $Y|Y>0$ (\texttt{type = "mean"}) or the inverse probability weights (\texttt{type = "contr"}). It is possible to set the \texttt{se.fit} argument to \texttt{TRUE} in order to obtain standard errors for each of those by using the $\delta$ method. Also, it is possible to use a custom covariance matrix for standard error computation (argument \texttt{cov}); \\
\texttt{redoPopEstimation} & a function that applies all post-hoc procedures that were performed (such as heteroscedastic consistent covariance matrix estimation via \textbf{countreg}) to estimate the population size and standard errors; \\
\texttt{residuals} & used for obtaining residuals of several types, we refer interested readers to the manual \texttt{?singleRcapture:::residuals.singleRStaticCountData}; \\
\texttt{stratifyPopsize, summary} & compared to the \texttt{glm} class, summary has the possibility of adding confidence intervals to the coefficient matrix (argument \texttt{confint = TRUE}) and using a custom covariance matrix (argument \texttt{cov = someMatrix}); \\
\texttt{plot} & it has been discussed above;\\
\texttt{popSizeEst} & an extractor showcased above; \\
\texttt{cooks.distance} & it works only for single predictor models \\
\texttt{dfbeta, dfpopsize} & Multi-threading in \texttt{dfbeta} is available and \texttt{dfpopsize} calls \texttt{dfbeta} if no \texttt{dfbeta} object was provided in the call; \\
\texttt{bread, estfun, vcovHC} & for (almost) full \textbf{sandwich} compatibility; \\
\texttt{AIC, BIC, extractAIC, family, confint, df.residual, model.frame, hatvalues, nobs, print, sigma, influence, rstudent, rstandard}  & it works exactly like \texttt{glm} counterparts.\\
\hline 
\end{tabular}
\caption{\texttt{S3Methods} implemented in the \textbf{singleRcapture}}
\label{tab-methods}
\end{table}

```{r, simulate-method}
set.seed(1234567890)
N <- 10000
gender <- rbinom(N, 1, 0.2)
eta <- -1 + 0.5*gender
counts <- simulate(ztpoisson(), eta = cbind(eta), seed = 1)
summary(data.frame(gender, eta, counts))
```

The full list of explicitly defined methods for \texttt{singleRStaticCountData} methods is presented in Table \ref{tab-methods}.

# Concluding remarks

In this paper we have introduced the \textbf{singleRcapture} package for single source capture-recapture models. The package implement state-of-the-art methods for estimating population size based on a single data set with multiple counts. The package implements different methods to account for heterogeneity in capture probabilities, modelled using covariates, as well as behavioural change, modelled using one-inflation. We have built the package to facilitate the implementation of new models using \texttt{family} objects; their application is exemplified in the Appendix \ref{sec-family}. An example of implementing a custom family described in Appendix \ref{sec-custom} is presented in replication materials.

Furthermore, since many \textbf{R} users are familiar with \textbf{countreg} or \textbf{VGAM} packages, we have implemented a lightweight extension called \textbf{singleRcaptureExtra}, available through Github (\url{https://github.com/ncn-foreigners/singleRcaptureExtra}), which can be used to integrate \textbf{singleRcapture} with these packages. 

In future work we plan to implement Bayesian estimation using \textbf{Stan} (e.g. via the \textbf{brms} package; \cite{carpenter2017stan, brms}) and for one-inflation models we can use the recent approach proposed by \cite{tuoto2022bayesian} and implement our own families using the \textbf{brms} package.

# Acknowledgements {#Acknowledgements}

The authors' work has been financed by the National Science Centre in Poland, OPUS 20, grant no. 2020/39/B/HS4/00941.

The authors would like to thank Peter van der Heijden, Maarten Cruyff, Dankmar Böhning, Łukasz Chrostowski and Layna Dennett for useful comments that have helped to improve the functionality of the package. In addition, we would like to thank Marcin Szymkowiak and Tymon Świtalski for their valuable comments that have considerably improved the paper.

\appendix

# Detailed information {#sec-details}

## The \texttt{estimatePopsizeFit} function {#sec-estimatePopsizeFit short-title="The estimatePopsizeFit function"}

In this section we provide a step-by-step description of how to prepare data in order to use the \texttt{estimatePopsizeFit} function, which may be useful to some users, e.g. those wishing to make modifications to the $\hat{N}$ estimate or to the bootstrap. In order to show how to apply the function we will fit a zero truncated geometric model on the data from @chao-generalization with covariate dependency:
\begin{align*}
  \log(\lambda) &=
  \beta_{1, 1} + \beta_{1, 2} \text{log\_distance} + \beta_{1, 3} \text{C\_TYPE} +
  \beta_{1, 4} \text{log\_size}, \\
  \text{logit}(\omega) &=
  \beta_{2, 1} + \beta_{2, 2} \text{log\_distance} + \beta_{2, 3} \text{C\_TYPE}.
\end{align*}

This would be equivalent to the following \texttt{esimatePopsize} call:
```{r, example-code-farm, eval=FALSE}
estimatePopsize(
  TOTAL_SUB ~ .,
  data = farmsubmission,
  model = ztoigeom(),
  controlModel(
    omegaFormula = ~ 1 + log_size + C_TYPE
  )
)
```

1. Create a data matrix $\bX_{\text{vlm}}$ 

```{r, estimatePopsizeFit-1}
X <- matrix(data = 0, nrow = 2 * NROW(farmsubmission), ncol = 7)
```

2. Fill the first $n$ rows with \texttt{model.matrix} according to the specified formula and specify the attribute \texttt{attr(X, "hwm")} that informs the function which elements of the design matrix correspond to which linear  predictor (covariates for counts and covariates for one-inflation)


```{r, estimatePopsizeFit-2}
X[1:NROW(farmsubmission), 1:4] <- model.matrix(
  ~ 1 + log_size + log_distance + C_TYPE, 
  farmsubmission
)
X[-(1:NROW(farmsubmission)), 5:7] <- model.matrix(
  ~ 1 + log_distance + C_TYPE, 
  farmsubmission
)
attr(X, "hwm") <- c(4, 3)
```

3. Obtain starting $\bbeta$ parameters using the \texttt{glm.fit} function.

```{r, estimatePopsizeFit-3}
start <- glm.fit(
  y = farmsubmission$TOTAL_SUB, 
  x = X[1:NROW(farmsubmission), 1:4], 
  family = poisson()
)$coefficients
start
```
4. Use the \texttt{estimatePopsizeFit} function to fit the model assuming a zero-truncated one-inflated geometric distribution as specified in the \texttt{family} argument.

```{r, estimatePopsizeFit-4}
res <- estimatePopsizeFit(
  y            = farmsubmission$TOTAL_SUB, 
  X            = X, 
  method       = "IRLS", 
  priorWeights = 1, 
  family       = ztoigeom(), 
  control      = controlMethod(silent = TRUE), 
  coefStart    = c(start, 0, 0, 0),
  etaStart     = matrix(X %*% c(start, 0, 0, 0), ncol = 2),
  offset       = cbind(rep(0, NROW(farmsubmission)), 
                       rep(0, NROW(farmsubmission)))
)
```

5. Compare our results with those obtained by applying the \texttt{stats::optim} function.

```{r, estimatePopsizeFit-5}
ll <- ztoigeom()$makeMinusLogLike(y = farmsubmission$TOTAL_SUB, X = X)
```

```{r, estimatePopsizeFit-6}
res2 <- estimatePopsizeFit(
  y = farmsubmission$TOTAL_SUB, 
  X = X, 
  method = "optim", 
  priorWeights = 1, 
  family = ztoigeom(), 
  coefStart = c(start, 0, 0, 0),
  control = controlMethod(silent = TRUE, maxiter = 10000),
  offset = cbind(rep(0, NROW(farmsubmission)), rep(0, NROW(farmsubmission)))
)
```

```{r, estimatePopsizeFit-7}
data.frame(IRLS  = round(c(res$beta, -ll(res$beta), res$iter), 4),
           optim = round(c(res2$beta, -ll(res2$beta), res2$iter[1]), 4))
```

The default \texttt{maxiter} parameter for \texttt{"optim"} fitting is $1000$, but we needed to increase it since the \texttt{optim} does not converge in $1000$ steps and "gets stuck" at a plateau, which results in a lower log-likelihood value compared to the standard \texttt{"IRLS"}.

The above situation is rather typical. While we did not conduct any formal numerical analyses, it seems that when one attempts to model more than one parameter of the distribution as covariate dependent \texttt{optim} algorithms, both \texttt{"Nelder-Mead"} and \texttt{"L-BFGS-B"} seem to be ill-suited for the task despite being provided with the analytically computed gradient. This is one of the reasons why \texttt{"IRLS"} is the default fitting method.

## Structure of a family function {#sec-family}

In this section we provide details regarding the \texttt{family} object for the \textbf{singleRcapture} package. This object contains additional parameters in comparison to the standard \texttt{family} object from the \texttt{stats} package.

\begin{table}[ht!]
\centering
\small
\begin{tabular}{p{4cm}p{11cm}}
\hline 
Function & Description \\
\hline
\texttt{makeMinusLogLike} & 
A factory function for creating the following functions:
  \begin{equation*}
    \ell(\bbeta), 
    \frac{\partial\ell}{\partial\bbeta},
    \frac{\partial^{2}\ell}{\partial\bbeta^\top\partial\bbeta}
  \end{equation*}
  from the $\boldsymbol{y}$ vector and the $\bX_{vlm}$ matrix, which has the \texttt{deriv} argument with possible 
  values in \texttt{c(0, 1, 2)} that determine which derivative to return; the default value is \texttt{0}, which represents the minus log-likelihood; \\
\texttt{links} & A list with link functions; \\
\texttt{mu.eta, variance} & Functions of linear predictors that return the expected value and variance. The \texttt{type} argument with 2 possible values (\texttt{"trunc"} and \texttt{"nontrunc"}) specifies whether to return $\mathbb{E}[Y|Y>0], \text{var}[Y|Y>0]$ or $\mathbb{E}[Y], \text{var}[Y]$ respectively; the \texttt{deriv} argument with values in \texttt{c(0, 1, 2)} is used for indicating the derivative with respect to the linear predictors, which is used for providing standard errors in the \texttt{predict} method; \\
\texttt{family} & A string that specifies the model name; \\
\texttt{valideta, validmu} & For now it only returns \texttt{TRUE}. In the near future, it will be used to check whether applied linear predictors are valid (i.e. are transformed into some elements of the parameter space subjected to the inverse link function); \\
\texttt{funcZ, Wfun} & Functions that create pseudo residuals and working weights used in the IRLS algorithm; \\
\texttt{devResids}  & A function that returns deviance residuals given a vector of prior weights of linear predictors and the response vector; \\
\texttt{pointEst, popVar} & Functions that return the point estimate for the population size and analytic estimation of its variance given prior weights of linear predictors and, in the later case, also estimates of  $\text{cov}(\hat{\bbeta})$ and $\bX_{\text{vlm}}$ matrix. There is an additional boolean parameter \texttt{contr} in the former function, which, if set to \texttt{TRUE}, returns the contribution of each unit; \\
\texttt{etaNames} & Names of linear predictors; \\
\texttt{densityFunction} & A function that returns the value of PMF at values of \texttt{x} given linear predictors. The \texttt{type} argument specifies whether to return $\mathbb{P}[Y|Y>0]$ or $\mathbb{P}[Y]$; \\
\texttt{simulate} & A function that generates values of a dependent  vector given linear predictors; \\
\texttt{getStart} & An expression for generating starting points; \\
\hline
\end{tabular}
\end{table}


# Implementing a custom \textbf{singleRcapture} family function {#sec-custom short-title="Implementing custom singleRcapture family function"}

Suppose we want to implement a very specific zero truncated family function in the \textbf{singleRcapture}, which corresponds to the following "untruncated" distribution: 

\begin{equation}
  \mathbb{P}[Y=y|\lambda, \pi] = \begin{cases}
    1 - \frac{1}{2}\lambda - \frac{1}{2}\pi & \text{when: } y=0\\
    \frac{1}{2}\pi & \text{when: } y=1\\
    \frac{1}{2}\lambda & \text{when: } y=2,
  \end{cases}
\end{equation} with $\lambda, \pi\in\left(0, 1\right)$ being dependent on covariates. 

Below we provide a possible way of implementing the above model, with \texttt{lambda, pi} meaning $\frac{1}{2}\lambda,\frac{1}{2}\pi$. We provide a simple example that shows that the proposed approach works as expected.

```{r custom-family-example}
myFamilyFunction <- function(lambdaLink = c("logit", "cloglog", "probit"),
                             piLink     = c("logit", "cloglog", "probit"),
                             ...) {
  if (missing(lambdaLink)) lambdaLink <- "logit"
  if (missing(piLink))         piLink <- "logit"

  links <- list()
  attr(links, "linkNames") <- c(lambdaLink, piLink)

  lambdaLink <- switch(lambdaLink,
                       "logit"   = singleRcapture:::singleRinternallogitLink,
                       "cloglog" = singleRcapture:::singleRinternalcloglogLink,
                       "probit"  = singleRcapture:::singleRinternalprobitLink
  )

  piLink <- switch(piLink,
                   "logit"   = singleRcapture:::singleRinternallogitLink,
                   "cloglog" = singleRcapture:::singleRinternalcloglogLink,
                   "probit"  = singleRcapture:::singleRinternalprobitLink
  )

  links[1:2] <- c(lambdaLink, piLink)

  mu.eta <- function(eta, type = "trunc", deriv = FALSE, ...) {
    pi     <-     piLink(eta[, 2], inverse = TRUE) / 2
    lambda <- lambdaLink(eta[, 1], inverse = TRUE) / 2

    if (!deriv) {
      switch (type,
              "nontrunc" = pi + 2 * lambda,
              "trunc" = 1 + lambda / (pi + lambda)
      )
    } else {
      # Only necessary if one wishes to use standard errors in predict method
      switch (type,
              "nontrunc" = {
                matrix(c(2, 1) * c(
                  lambdaLink(eta[, 1], inverse = TRUE, deriv = 1) / 2,
                  piLink(eta[, 2], inverse = TRUE, deriv = 1) / 2
                ), ncol = 2)
              },
              "trunc" = {
                matrix(c(
                  pi / (pi + lambda) ^ 2,
                  -lambda / (pi + lambda) ^ 2
                ) * c(
                  lambdaLink(eta[, 1], inverse = TRUE, deriv = 1) / 2,
                  piLink(eta[, 2], inverse = TRUE, deriv = 1) / 2
                ), ncol = 2)
              }
      )
    }
  }

  variance <- function(eta, type = "nontrunc", ...) {
    pi     <-     piLink(eta[, 2], inverse = TRUE) / 2
    lambda <- lambdaLink(eta[, 1], inverse = TRUE) / 2

    switch (type,
            "nontrunc" = pi * (1 - pi) + 4 * lambda * (1 - lambda - pi),
            "trunc" = lambda * (1 - lambda) / (pi + lambda)
    )
  }

  Wfun <- function(prior, y, eta, ...) {
    pi     <-     piLink(eta[, 2], inverse = TRUE) / 2
    lambda <- lambdaLink(eta[, 1], inverse = TRUE) / 2

    G01 <- ((lambda + pi) ^ (-2)) * piLink(eta[, 2], inverse = TRUE, deriv = 1) *
      lambdaLink(eta[, 1], inverse = TRUE, deriv = 1) * prior / 4

    G00 <- ((lambda + pi) ^ (-2)) - (pi ^ (-2)) - lambda / ((lambda + pi) * (pi ^ 2))
    G00 <- G00 * prior * (piLink(eta[, 2], inverse = TRUE, deriv = 1) ^ 2) / 4

    G11 <- ((lambda + pi) ^ (-2)) - (((lambda + pi) * lambda) ^ -1)
    G11 <- G11 * prior * (lambdaLink(eta[, 1], inverse = TRUE, deriv = 1) ^ 2) / 4

    matrix(
      -c(G11, # lambda
         G01, # mixed
         G01, # mixed
         G00  # pi
      ),
      dimnames = list(rownames(eta), c("lambda", "mixed", "mixed", "pi")),
      ncol = 4
    )
  }

  funcZ <- function(eta, weight, y, prior, ...) {
    pi     <-     piLink(eta[, 2], inverse = TRUE) / 2
    lambda <- lambdaLink(eta[, 1], inverse = TRUE) / 2

    weight <- weight / prior

    G0 <- (2 - y) / pi     - ((lambda + pi) ^ -1)
    G1 <- (y - 1) / lambda - ((lambda + pi) ^ -1)

    G1 <- G1 * lambdaLink(eta[, 1], inverse = TRUE, deriv = 1) / 2
    G0 <- G0 *     piLink(eta[, 2], inverse = TRUE, deriv = 1) / 2

    uMatrix <- matrix(c(G1, G0), ncol = 2)

    weight <- lapply(X = 1:nrow(weight), FUN = function (x) {
      matrix(as.numeric(weight[x, ]), ncol = 2)
    })

    pseudoResid <- sapply(X = 1:length(weight), FUN = function (x) {
      #xx <- chol2inv(chol(weight[[x]])) # less computationally demanding
      xx <- solve(weight[[x]]) # more stable
      xx %*% uMatrix[x, ]
    })
    pseudoResid <- t(pseudoResid)
    dimnames(pseudoResid) <- dimnames(eta)
    pseudoResid
  }

  minusLogLike <- function(y, X, offset,
                           weight    = 1,
                           NbyK      = FALSE,
                           vectorDer = FALSE,
                           deriv     = 0,
                           ...) {
    y <- as.numeric(y)
    if (is.null(weight)) {
      weight <- 1
    }
    if (missing(offset)) {
      offset <- cbind(rep(0, NROW(X) / 2), rep(0, NROW(X) / 2))
    }

    if (!(deriv %in% c(0, 1, 2)))
      stop("Only score function and derivatives up to 2 are supported.")
    deriv <- deriv + 1

    switch (deriv,
            function(beta) {
              eta <- matrix(as.matrix(X) %*% beta, ncol = 2) + offset
              pi     <-     piLink(eta[, 2], inverse = TRUE) / 2
              lambda <- lambdaLink(eta[, 1], inverse = TRUE) / 2
              -sum(weight * ((2 - y) * log(pi) + (y - 1) * log(lambda) - log(pi + lambda)))
            },
            function(beta) {
              eta <- matrix(as.matrix(X) %*% beta, ncol = 2) + offset
              pi     <-     piLink(eta[, 2], inverse = TRUE) / 2
              lambda <- lambdaLink(eta[, 1], inverse = TRUE) / 2

              G0 <- (2 - y) / pi     - ((lambda + pi) ^ -1)
              G1 <- (y - 1) / lambda - ((lambda + pi) ^ -1)

              G1 <- G1 * weight * lambdaLink(eta[, 1], inverse = TRUE, deriv = 1) / 2
              G0 <- G0 * weight *     piLink(eta[, 2], inverse = TRUE, deriv = 1) / 2

              if (NbyK) {
                XX <- 1:(attr(X, "hwm")[1])
                return(cbind(as.data.frame(X[1:nrow(eta), XX]) * G1,
                             as.data.frame(X[-(1:nrow(eta)), -XX]) * G0))
              }
              if (vectorDer) {
                return(cbind(G1, G0))
              }

              as.numeric(c(G1, G0) %*% X)
            },
            function (beta) {
              lambdaPredNumber <- attr(X, "hwm")[1]
              eta <- matrix(as.matrix(X) %*% beta, ncol = 2) + offset
              pi     <-     piLink(eta[, 2], inverse = TRUE) / 2
              lambda <- lambdaLink(eta[, 1], inverse = TRUE) / 2

              res <- matrix(nrow = length(beta), ncol = length(beta),
                            dimnames = list(names(beta), names(beta)))

              # pi^2 derivative
              dpi <- (2 - y) / pi - (lambda + pi) ^ -1
              G00 <- ((lambda + pi) ^ (-2)) - (2 - y) / (pi ^ 2)

              G00 <- t(as.data.frame(X[-(1:(nrow(X) / 2)), -(1:lambdaPredNumber)] *
                                       (G00 * ((piLink(eta[, 2], inverse = TRUE, deriv = 1) / 2) ^ 2) +
                                          dpi * piLink(eta[, 2], inverse = TRUE, deriv = 2) / 2) * weight)) %*%
                as.matrix(X[-(1:(nrow(X) / 2)), -(1:lambdaPredNumber)])
              # mixed derivative
              G01 <- (lambda + pi) ^ (-2)

              G01 <- t(as.data.frame(X[1:(nrow(X) / 2), 1:lambdaPredNumber]) *
                         G01 * (lambdaLink(eta[, 1], inverse = TRUE, deriv = 1) / 2) *
                         (piLink(eta[, 2], inverse = TRUE, deriv = 1) / 2) * weight) %*%
                as.matrix(X[-(1:(nrow(X) / 2)), -(1:lambdaPredNumber)])
              # lambda^2 derivative
              G11 <- ((lambda + pi) ^ (-2)) - (y - 1) / (lambda ^ 2)
              dlambda <- (y - 1) / lambda - ((lambda + pi) ^ -1)

              G11 <- t(as.data.frame(X[1:(nrow(X) / 2), 1:lambdaPredNumber] *
                                       (G11 * ((lambdaLink(eta[, 1], inverse = TRUE, deriv = 1) / 2) ^ 2) +
                                          dlambda * lambdaLink(eta[, 1], inverse = TRUE, deriv = 2) / 2) * weight)) %*%
                X[1:(nrow(X) / 2), 1:lambdaPredNumber]

              res[-(1:lambdaPredNumber), -(1:lambdaPredNumber)] <- G00
              res[1:lambdaPredNumber, 1:lambdaPredNumber] <- G11
              res[1:lambdaPredNumber, -(1:lambdaPredNumber)] <- t(G01)
              res[-(1:lambdaPredNumber), 1:lambdaPredNumber] <- G01

              res
            }
    )
  }

  validmu <- function(mu) {
    (sum(!is.finite(mu)) == 0) && all(0 < mu) && all(2 > mu)
  }

  # this is optional
  devResids <- function(y, eta, wt, ...) {
    0
  }

  pointEst <- function (pw, eta, contr = FALSE, ...) {
    pi     <-     piLink(eta[, 2], inverse = TRUE) / 2
    lambda <- lambdaLink(eta[, 1], inverse = TRUE) / 2
    N <- pw / (lambda + pi)
    if(!contr) {
      N <- sum(N)
    }
    N
  }

  popVar <- function (pw, eta, cov, Xvlm, ...) {
    pi     <-     piLink(eta[, 2], inverse = TRUE) / 2
    lambda <- lambdaLink(eta[, 1], inverse = TRUE) / 2

    bigTheta1 <- -pw / (pi + lambda) ^ 2 # w.r to pi
    bigTheta1 <- bigTheta1 * piLink(eta[, 2], inverse = TRUE, deriv = 1) / 2
    bigTheta2 <- -pw / (pi + lambda) ^ 2 # w.r to lambda
    bigTheta2 <- bigTheta2 * lambdaLink(eta[, 1], inverse = TRUE, deriv = 1) / 2 # w.r to lambda

    bigTheta <- t(c(bigTheta2, bigTheta1) %*% Xvlm)

    f1 <- t(bigTheta) %*% as.matrix(cov) %*% bigTheta

    f2 <- sum(pw * (1 - pi - lambda) / ((pi + lambda) ^ 2))

    f1 + f2
  }

  dFun <- function (x, eta, type = c("trunc", "nontrunc")) {
    if (missing(type)) type <- "trunc"
    pi     <-     piLink(eta[, 2], inverse = TRUE) / 2
    lambda <- lambdaLink(eta[, 1], inverse = TRUE) / 2

    switch (type,
            "trunc" = {
              (pi * as.numeric(x == 1) + lambda * as.numeric(x == 2)) / (pi + lambda)
            },
            "nontrunc" = {
              (1 - pi - lambda) * as.numeric(x == 0) +
                pi * as.numeric(x == 1) + lambda * as.numeric(x == 2)
            }
    )
  }

  simulate <- function(n, eta, lower = 0, upper = Inf) {
    pi     <-     piLink(eta[, 2], inverse = TRUE) / 2
    lambda <- lambdaLink(eta[, 1], inverse = TRUE) / 2
    CDF <- function(x) {
      ifelse(x == Inf, 1,
             ifelse(x < 0, 0,
                    ifelse(x < 1, 1 - pi - lambda,
                           ifelse(x < 2, 1 - lambda, 1))))
    }
    lb <- CDF(lower)
    ub <- CDF(upper)
    p_u <- stats::runif(n, lb, ub)
    sims <- rep(0, n)
    cond <- CDF(sims) <= p_u
    while (any(cond)) {
      sims[cond] <- sims[cond] + 1
      cond <- CDF(sims) <= p_u
    }
    sims
  }

  getStart <- expression(
    if (method == "IRLS") {
      etaStart <- cbind(
        family$links[[1]](mean(observed == 2) * (1 + 0 * (observed == 2))), # lambda
        family$links[[2]](mean(observed == 1) * (1 + 0 * (observed == 1)))  # pi
      ) + offset
    } else if (method == "optim") {
      init <- c(
        family$links[[1]](weighted.mean(observed == 2, priorWeights) * 1 + .0001),
        family$links[[2]](weighted.mean(observed == 1, priorWeights) * 1 + .0001)
      )
      if (attr(terms, "intercept")) {
        coefStart <- c(init[1], rep(0, attr(Xvlm, "hwm")[1] - 1))
      } else {
        coefStart <- rep(init[1] / attr(Xvlm, "hwm")[1], attr(Xvlm, "hwm")[1])
      }
      if ("(Intercept):pi" %in% colnames(Xvlm)) {
        coefStart <- c(coefStart, init[2], rep(0, attr(Xvlm, "hwm")[2] - 1))
      } else {
        coefStart <- c(coefStart, rep(init[2] / attr(Xvlm, "hwm")[2], attr(Xvlm, "hwm")[2]))
      }
    }
  )

  structure(
    list(
      makeMinusLogLike = minusLogLike,
      densityFunction  = dFun,
      links     = links,
      mu.eta    = mu.eta,
      valideta  = function (eta) {TRUE},
      variance  = variance,
      Wfun      = Wfun,
      funcZ     = funcZ,
      devResids = devResids,
      validmu   = validmu,
      pointEst  = pointEst,
      popVar    = popVar,
      family    = "myFamilyFunction",
      etaNames  = c("lambda", "pi"),
      simulate  = simulate,
      getStart  = getStart,
      extraInfo = c(
        mean       = "pi / 2 + lambda",
        variance   = paste0("(pi / 2) * (1 - pi / 2) + 2 * lambda * (1 - lambda / 2 - pi / 2)"),
        popSizeEst = "(1 - (pi + lambda) / 2) ^ -1",
        meanTr     = "1 + lambda / (pi + lambda)",
        varianceTr = paste0("lambda * (1 - lambda / 2) / (pi + lambda)")
      )
    ),
    class = c("singleRfamily", "family")
  )
}
```

A quick tests shows us that this implementation in fact works:

```{r}
set.seed(123)
Y <- simulate(
  myFamilyFunction(lambdaLink = "logit", piLink = "logit"),
  nsim = 1000, eta = matrix(0, nrow = 1000, ncol = 2),
  truncated = FALSE
)
mm <- estimatePopsize(
  formula = Y ~ 1,
  data = data.frame(Y = Y[Y > 0]),
  model = myFamilyFunction(lambdaLink = "logit",
                           piLink = "logit"),
  # the usual observed information matrix
  # is ill-suited for this distribution
  controlPopVar = controlPopVar(covType = "Fisher")
)
summary(mm)
```

where the link functions, such as `singleRcapture:::singleRinternalcloglogLink`, are just internal functions in `singleRcapture` that compute link functions, their inverses and derivatives of both links and inverse links up to the third order:

```{r single-link}
singleRcapture:::singleRinternalcloglogLink
```

One could, of course, include the code for computing them manually.


