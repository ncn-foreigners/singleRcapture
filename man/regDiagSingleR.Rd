% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/documentationFiles.R, R/leave-one-out.R,
%   R/miscDiagnostics.R, R/smallMethods.R
\name{regDiagSingleR}
\alias{regDiagSingleR}
\alias{dfpopsize}
\alias{dfpopsize.singleRStaticCountData}
\alias{dfbeta.singleRStaticCountData}
\alias{hatvalues.singleRStaticCountData}
\alias{residuals.singleRStaticCountData}
\alias{cooks.distance.singleRStaticCountData}
\alias{sigma.singleRStaticCountData}
\alias{influence.singleRStaticCountData}
\alias{rstudent.singleRStaticCountData}
\alias{rstandard.singleRStaticCountData}
\title{Regression diagnostics in singleRcapture}
\usage{
dfpopsize(model, ...)

\method{dfpopsize}{singleRStaticCountData}(model, dfbeta = NULL, ...)

\method{dfbeta}{singleRStaticCountData}(model, maxitNew = 1, trace = FALSE, cores = 1, ...)

\method{hatvalues}{singleRStaticCountData}(model, ...)

\method{residuals}{singleRStaticCountData}(
  object,
  type = c("pearson", "pearsonSTD", "response", "working", "deviance", "all"),
  ...
)

\method{cooks.distance}{singleRStaticCountData}(model, ...)

\method{sigma}{singleRStaticCountData}(object, ...)

\method{influence}{singleRStaticCountData}(model, do.coef = FALSE, ...)

\method{rstudent}{singleRStaticCountData}(model, ...)

\method{rstandard}{singleRStaticCountData}(model, type = c("deviance", "pearson"), ...)
}
\arguments{
\item{model, object}{an object of \code{singleRStaticCountData} class.}

\item{...}{arguments passed to other methods.
Notably \code{dfpopsize.singleRStaticCountData} calls
\code{dfbeta.singleRStaticCountData} if no \code{dfbeta} argument was
provided and \code{controlMethod} is called in \code{dfbeta} method.}

\item{dfbeta}{if \code{dfbeta} was already obtained it is possible to pass
them into function so that they need not be computed for the second time.}

\item{maxitNew}{the maximal number of iterations for regressions with starting
points \mjseqn{\hat{\boldsymbol{\beta}}} on data
specified at call for \code{model} after the removal of k'th row. By default 1.}

\item{trace}{a logical value specifying whether to tracking results when
\code{cores > 1} it will result in a progress bar being created.}

\item{cores}{a number of processor cores to be used,
any number greater than 1 activates code designed with \code{doParallel},
\code{foreach} and \code{parallel} packages. Note that for now using parallel
computing makes tracing impossible so \code{trace} parameter is ignored in this case.}

\item{type}{a type of residual to return.}

\item{do.coef}{logical indicating if \code{dfbeta} computation for influence
should be done. \code{FALSE} by default.}
}
\value{
\itemize{
\item For \code{hatvalues} -- A matrix with n rows and p columns where n is a
number of observations in the data and p is number of regression parameters.
\item For \code{dfpopsize} -- A vector for which k'th element corresponds
to the difference between point estimate of population size estimation on
full data set and point estimate of population size estimation after the
removal of k'th unit from the data set.
\item For \code{dfbeta} -- A matrix with n rows and p observations where p
is a number of units in data and p is the number of regression parameters.
K'th row of this matrix corresponds to
\mjseqn{\hat{\boldsymbol{\beta}}-\hat{\boldsymbol{\beta}}_{-k}}
where \mjseqn{\hat{\boldsymbol{\beta}}_{-k}} is a vector of estimates for
regression parameters after the removal of k'th row from the data.
\item \code{cooks.distance} -- A matrix with a single columns with
values of cooks distance for every unit in \code{model.matrix}
\item \code{residuals.singleRStaticCountData} -- A \code{data.frame}
with chosen residuals.
}
}
\description{
List of some regression diagnostics implemented for
\code{singleRStaticCountData} class. Functions that either require no changes from
\code{glm} class or are not relevant to context of \code{singleRcapture}
are omitted.
}
\details{
\loadmathjax

\code{dfpopsize} and \code{dfbeta} are closely related. \code{dfbeta}
fits a regression after removing a specific row from the data and returns the
difference between regression coefficients estimated on full data set and
data set obtained after deletion of that row, and repeats procedure once
for every unit present in the data.\code{dfpopsize} does the same for
population size estimation utilizing coefficients computed by \code{dfbeta}.

\code{cooks.distance} is implemented (for now) only for models with a single
linear predictor and works exactly like the method for \code{glm} class.

\code{sigma} computes the standard errors of predicted means. Returns a matrix
with two columns first for truncated mean and the other for the non-truncated mean.

\code{residuals.singleRStaticCountData} (can be abbreviated to \code{resid})
works like \code{residuals.glm} with the exception that:
\itemize{
\item \code{"pearson"} -- returns non standardized residuals.
\item \code{"pearsonSTD"} -- is currently defined only for single predictors
models but will be extended to all models in a near future, but for families
with more than one distribution parameter it will be a multivariate residual.
\item \code{"response"} -- returns both residuals computed with truncated
and non truncated fitted value.
\item \code{"working"} -- is possibly multivariate if more than one linear
predictor is present.
\item \code{"deviance"} -- is not yet defined for all families in
\code{\link[=singleRmodels]{singleRmodels()}} e.g. negative binomial based methods.
\item \code{"all"} -- returns all available residual types.
}

\code{hatvalues.singleRStaticCountData} is method for \code{singleRStaticCountData}
class for extracting diagonal elements of projection matrix.

Since \code{singleRcapture} supports not only regular glm's but also vglm's the
\code{hatvalues} returns a matrix with number of columns corresponding to number
of linear predictors in a model, where kth column corresponds to elements of
the diagonal of projection matrix associated with kth linear predictor.
For glm's
\mjsdeqn{\boldsymbol{W}^{\frac{1}{2}}\boldsymbol{X}
\left(\boldsymbol{X}^{T}\boldsymbol{W}\boldsymbol{X}\right)^{-1}
\boldsymbol{X}^{T}\boldsymbol{W}^{\frac{1}{2}}}
where: \mjseqn{\boldsymbol{W}=\mathbb{E}\left(\text{Diag}
\left(\frac{\partial^{2}\ell}{\partial\boldsymbol{\eta}^{T}
\partial\boldsymbol{\eta}}\right)\right)}
and \mjseqn{\boldsymbol{X}} is a model (lm) matrix.
For vglm's present in the package it is instead :
\mjsdeqn{\boldsymbol{X}_{vlm}
\left(\boldsymbol{X}_{vlm}^{T}\boldsymbol{W}\boldsymbol{X}_{vlm}\right)^{-1}
\boldsymbol{X}_{vlm}^{T}\boldsymbol{W}}
where:
\mjsdeqn{
\boldsymbol{W} = \mathbb{E}\left(\begin{bmatrix}
\text{Diag}\left(\frac{\partial^{2}\ell}{\partial\eta_{1}^{T}\partial\eta_{1}}\right) &
\text{Diag}\left(\frac{\partial^{2}\ell}{\partial\eta_{1}^{T}\partial\eta_{2}}\right) &
\dotso & \text{Diag}\left(\frac{\partial^{2}\ell}{\partial\eta_{1}^{T}\partial\eta_{p}}\right)\cr
\text{Diag}\left(\frac{\partial^{2}\ell}{\partial\eta_{2}^{T}\partial\eta_{1}}\right) &
\text{Diag}\left(\frac{\partial^{2}\ell}{\partial\eta_{2}^{T}\partial\eta_{2}}\right) &
\dotso & \text{Diag}\left(\frac{\partial^{2}\ell}{\partial\eta_{2}^{T}\partial\eta_{p}}\right)\cr
\vdots & \vdots & \ddots & \vdots\cr
\text{Diag}\left(\frac{\partial^{2}\ell}{\partial\eta_{p}^{T}\partial\eta_{1}}\right) &
\text{Diag}\left(\frac{\partial^{2}\ell}{\partial\eta_{p}^{T}\partial\eta_{2}}\right) &
\dotso & \text{Diag}\left(\frac{\partial^{2}\ell}{\partial\eta_{p}^{T}\partial\eta_{p}}\right)
\end{bmatrix}\right)}
is a block matrix constructed by taking the expected  value from diagonal
matrixes corresponding to second derivatives with respect to each linear
predictor (and mixed derivatives) and
\mjseqn{\boldsymbol{X}_{vlm}} is a model (vlm)
matrix constructed using specifications in \code{controlModel} and
call to \code{estimatePopsize}.

\code{influence} works like \code{glm} counterpart computing the most important
influence measures.
}
\examples{
\donttest{
# For singleRStaticCountData class
# Get simple model
Model <- estimatePopsize(
  formula = capture ~ nation + age + gender, 
  data = netherlandsimmigrant, 
  model = ztpoisson, 
  method = "IRLS"
)
# Get dfbeta
dfb <- dfbeta(Model)
# The dfpopsize results are obtained via (It is also possible to not provide 
# dfbeta then they will be computed manually):
res <- dfpopsize(Model, dfbeta = dfb)
summary(res)
plot(res)
# see vaious types of residuals:
head(resid(Model, "all"))
}
}
\seealso{
\code{\link[=estimatePopsize]{estimatePopsize()}} \code{\link[stats:influence.measures]{stats::hatvalues()}} \code{\link[=controlMethod]{controlMethod()}} \code{\link[stats:influence.measures]{stats::dfbeta()}}
\code{\link[stats:influence.measures]{stats::cooks.distance()}}
}
\author{
Piotr Chlebicki, Maciej BerÄ™sewicz
}
